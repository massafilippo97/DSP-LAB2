'use strict';

const db = require('../db.js');

/**
 * Retrieve the list of all the assignes of that task
 *
 * taskId Long Task id to delete
 * returns List
 **/
exports.tasksTaskIdImagesGET = function(taskId) {
  return new Promise(function(resolve, reject) {
    var sql_query = "select u.id, u.email, u.name from users u, assignments a where a.user = u.id AND a.task = ?;";

    db.all(sql_query, [taskId], (err, rows) =>{ 
      if(err) {
        reject(err);
        return;
      }
      if(rows.length === 0) {
        reject("taskId not found");
        return;
      }
      resolve(rows.map((row) => ({ 
        id: row.id, 
        email: row.email, 
        name: row.name, //dovrei rendere accessibili le risorse utente globali?
        _links: {
          self: {href: "http://localhost:8080/users/"+row.id},
          tasks: {href: "http://localhost:8080/tasks"},
          task: {href: "http://localhost:8080/tasks/{taskId}"},
          assignedTo: {href: "http://localhost:8080/tasks/{taskId}/assignedTo"},
          markTask: {href: "http://localhost:8080/tasks/{taskId}/markTask"},
          login: {href: "http://localhost:8080/login"}
        }
      })));
    });
  }); 
}



/**
 * Retrieve the specific tasks by its ID
 *
 * taskId Long Task id to delete
 * returns List
 * 
 * The user can retrieve a single existing task, identified by the specified id, if at least one of the following conditions is satisfied:
 * 1) the task is public;
 * 2) the user is the owner of the task;
 * 3) the user is an assignee of the task.
 **/
 exports.tasksTaskIdImagesImageIdGET = function(taskId, userId) {
    return new Promise(function(resolve, reject) {
   
        var sql_query = "SELECT t.id, t.description, t.important, t.private, t.project, t.deadline, t.completed, t.owner FROM assignments a, tasks t WHERE t.id = a.task and t.id = ? AND a.user = ? UNION SELECT * FROM tasks WHERE id = ? and owner = ? UNION SELECT * FROM tasks WHERE id = ? and owner = ?;" //union delle assignedToMe e createdByMe queries+ restanti tasks public
  
      
      db.all(sql_query, [taskId, userId, taskId, userId, taskId, userId], (err, rows) =>{
        if(err){
          reject(err);
          return;
        }
        if(rows.length === 0 && userId !== undefined) {
          reject("taskId not found");
          return;
        } 
        resolve(rows.map((row) => ({ 
          id: row.id, 
          description: row.description, 
          important: row.important, 
          private: row.private, 
          project: row.project, 
          deadline: row.deadline, 
          completed: row.completed, 
          owner: row.owner,
          _links: {
            self: {href: "http://localhost:8080/tasks/"+row.id},
            tasks: {href: "http://localhost:8080/tasks"},
            user: {href: "http://localhost:8080/users/{userId}"},
            assignedTo: {href: "http://localhost:8080/tasks/{taskId}/assignedTo"},
            markTask: {href: "http://localhost:8080/tasks/{taskId}/markTask"},
            login: {href: "http://localhost:8080/login"}
          }
        })));
      });
    });
  };



/**
 * Add a new task (ID is automatically generated by the server and the creator becomes its owner [assignees list is left empty])
 *
 * body List It is required a single Task object (optional)
 * no response value expected for this operation
 **/
 exports.tasksTaskIdImagesPOST = function(body, user_id, max_id) { //body == new task
    return new Promise(function(resolve, reject) {
      const sql_query = "INSERT INTO tasks(id,description,important,private,project,deadline,completed,owner) VALUES (?,?,?,?,?,?,?,?)";
      db.run(sql_query, [max_id, body.description, body.important, body.private, body.project, body.deadline, body.completed, user_id], (err, rows)=>{
        if(err) {
          reject(err);
          return;
        }
        resolve({ 
          id: max_id, 
          description: body.description, 
          important: body.important, 
          private: body.private, 
          project: body.project, 
          deadline: body.deadline, 
          completed: body.completed, 
          owner: user_id,
          _links: {
            self: {href: "http://localhost:8080/tasks/"+max_id},
            tasks: {href: "http://localhost:8080/tasks"},
            user: {href: "http://localhost:8080/users/{userId}"},
            assignedTo: {href: "http://localhost:8080/tasks/{taskId}/assignedTo"},
            markTask: {href: "http://localhost:8080/tasks/{taskId}/markTask"},
            login: {href: "http://localhost:8080/login"}
          }
        });
      });
    });
  };
  

/**
 * Delete an existing task by ID (if the requester is the owner)
 *
 * taskId Long Task id to delete
 * no response value expected for this operation
 **/
 exports.tasksTaskIdImagesImageIdDELETE = function(taskId) {
    return new Promise((resolve, reject)=> {
      const sql_query = 'DELETE FROM tasks WHERE id=?';
      db.run(sql_query, [taskId], (err, rows)=>{
        if(err) {
          reject(err);
          return;
        }
        resolve(null);
      });
    });
  };